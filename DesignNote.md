# CP/Mega88設計ノート

この文書は、`@tendai22plus`が行った変更についてのメモだが、
当初の`@toyoshim`さんの設計の背景を想像しつつ、それとの対比で説明したい。

# CP/Mega88とは何か？

* CP/Mを実行する環境である。
* 実8080/Z80 CPUを使わずに、ソフトエミュレートする。
* ソフトエミュレートと、周辺機能(シリアル、フロッピーディスク)エミュレートの
ためのCPUがある。
* CPU内蔵のRAMでは足りないことが多く、SRAM/DRAMを外付けする。
* フロッピーディスクの代わりにSDcardを使用する。
* RAM64k環境を提供する。

それぞれに説明を加える。

## CP/M

CP/Mはインテル8080, ザイログZ80 CPU上で動作する、プログラム実行環境・
開発環境である。当時はDOS(Disk Operating System)と呼んでいた。
シリアルコンソールとフロッピードライブを搭載するマイクロコンピュータ上で
動作させることを想定している。

80年代にマイコンを触っていた人たちは、CP/M上で生活していた人もおり、
懐かしくも触ってみたくなる環境といえる。少なくとも私はそう感じている。

## ソフトエミュレート

8080/Z80 CPUのソフトエミューレート機能は容易に手に入る。それを組み込んで
CP/M実行環境を作りたいというのは、昔CP/Mを触っていた人にとっては
魅力的だと思う。

今ならWindows/Linux上で、フロッピードライブやシリアルコンソールをエミュレート
して動作させることも容易だが、CP/Mega88では、それをせず、別途
マイクロコントローラを使いWindows/Linuxを使わず実現できることも特徴だろう。
この「Windows/Linux上ではなく、あえてマイクロコントローラ上で動作させる」
もCP/Mega88の特徴だと思う。

## マイクロコントローラ+RAM+SDcard

CP/M環境を実現するための構成要素は、8080/Z80 CPU、RAM、フロッピードライブ、
シリアルインタフェースである。
これをマイクロコントローラ、RAM、SDcardで実現している。
どれも、今入手可能で比較的安価である。

マイクロコントローラ: CP/Mega88ではその名前が表すように ATmega88を使っている。私は Raspberry Pi Picoで実現したが、ATmega328, PIC18F43Q47、ATmega4323、
STM32、でも実現可能だろう。

ATmega88含め、RAM64kバイト内蔵していないマイクロコントローラは多く、
それらの場合は外付けRAMを使う。マイクロコントローラのGPIOの数が少ない場合は、
RAMアクセスのための出力ピン数を確保するために多重化のために外部バッファを
搭載する。

フロッピーディスクに代わる記憶媒体が必要になる。当時のフロッピー容量は128kB, 
260kB～12Mbyteであった。今ならSDcard/microSDcard1枚で十分その容量は
まかなえる。

## RAM64k環境

8080, Z80のアドレス空間は16bit、64kBだが、RAMデバイスが高価であったため、
65536バイト全てをROM/RAMで埋めることは憧れの世界であった。
CP/Mは全RAM構成で、RAM容量は最小で20kBから動作させられた。
もちろん、その上で動かすプログラムはそれでは使い物にならないものも多く、
RAM 64kB使える環境は絶対欲しいところである。

# 実現形態のバリエーション

## ソフトエミュレーション

RAM/フロッピーディスク/コンソール全てソフトウェアで実現する。
DOS窓やLinuxシェル上で実行することでコンソール環境となり、
フロッピーディスクをファイルとして実現することが多い。

## マイクロコントローラ+RAM+SDcard

CP/Mega88はこれで、外付けRAMを使う。フロッピーディスク代わりにSDcardを
使用する。SDcard中にフロッピーディスクイメージファイルを置き、
それを読み書きするのが一般的であるが、SDcard上にフロッピーディスクイメージを
焼き込んで使う方法もある。

## マイクロコントローラ内蔵のリソースを用いる。

内蔵RAM上に65536バイトの配列が確保できれば、外付けRAMを使う必要はない。
大量のFLASHメモリを搭載するマイクロコントローラであれば、
そこにフロッピーディスクイメージを置くこともできる。
Raspberry Pi Pico上の実装では、基板上のQSPI Flashメモリ(プログラム搭載用、2MB)の一部にフロッピーディスクイメージを置いた。Pico基板単独でCP/Mega88を動作させている。

# ソフト構成

以後は、マイクロコントローラ上で動作させるソフトウェアの構成を見てゆく。
ソースコード名の`XXX`は、特定のマイクロコントローラ`XXX`専用・機種依存の
コードを含む。

* platform_XXX.c: プラットフォーム、
* monitor.c: モニター
* CPUエミュレーション
* con_XXX.c: シリアルアクセス
* sram_XXX.c: RAMアクセス
* sdcard_XXX.c: sdcardアクセス
* fat.c: FATファイルアクセス
* eeprom_XXX.c: EEPROMアクセス
* led_XXX.c: LEDアクセス
* io_XXX.c: 周辺I/O(GPIO)アクセス

## プラットフォーム(プログラム起動)

platform_XXX.c: main関数はここに置く。
main関数はmonitor関数を呼び出すだけ担っている。

マイクロコントローラリセット関数もここで定義している。Pico版では、watchdog timerのハードウェアリセット機能を用いている。pico-sdkのhardware/resetは、
マイクロコントローラのペリフェラルを個別にリセットする機能であり、これを呼び出してもCPU自体はリセットしない。

## モニター

monitor.c: コマンドラインインタフェース上でコマンドと引数を打ち込み実行させる。
```
(モニターコマンドリスト)
```
メモリダンプ、sdcardセクター読み書きができる。

私の実装では、フラッシュメモリダンプ、XMODEM経由でフロッピーディスクイメージの書き込みと読み出しを追加した。

`m(mount)`コマンドでフロッピーディスクイメージを指定し、
`b(boot)`コマンドでCP/Mシステムをブートし、以後、CP/Mコマンドを使用できる。

CP/M環境で`bye`コマンドを実行するとCP/Mを抜け出しモニターに戻る。

## CPUエミュレーション

8080は2種(cpu_8080.c, i8080.S)、Z80は1種類の実装を含む。コンパイルオプションで選択できる。エミュレーションの質についてはよくわかっていない。CP/Mを動かせる程度には十分ということだろう。

## con_XXX.c: シリアルアクセス

UARTの読み書き、Linux(con_posix.c)では、標準入出力のR/Wである。
1バイト読み込み(timeout指定可能)、1バイト書き込み、受信可能かどうかの3関数を提供する。

## sram_XXX.c: RAMアクセス

1バイト読み書き関数を提供する。

外部RAMの場合はGPIOを叩いてアドレス出力、OE, WEピンのON/OFF、データバスのRead/Writeを行う。内部RAMの場合は、バイト配列 `sram[65536]`を定義しそれへのRead/Writeを提供する。AVR版は前者、PICO版は後者である。

## sdcard_XXX.c: sdcardアクセス

SDcardをSPIモードでアクセスし、カード内の任意のセクタを読み書きする機能を提供する。読み書きするセクタはRAM上のバイト配列(512バイト)上に置かれ、そこへのアクセス関数が提供される。

SPIアクセスは、ハードウェア(マイクロコントローラのSPIコントローラを使用する)とソフトエミュレーション(CS,SCLK,MOSI,MISOをGPIOを使いOn/OffしてSDcardのSPIモードを喋る)がある。

AVR版はソフトエミュレーションを行う。他のマイクロコントローラにも参考になるだろう。Pico版ではSPIコントローラspi0をPin1,2,3,4で使っている。

Unix版は、sdcard_posix.cである。POSIXファイルI/O(fopen,fclose,fread,fwrite,fseek)を用いて、フロッピーディスクイメージを扱う。

## fat.c: FATファイルアクセス

sdcard_XXX.cが提供するセクタRead/Write機能を用いて、SDcard中のFATファイル1本を512バイト単位で読み書きする。

ファイル1本のみ、そのファイルに既にあるセクタのみへのアクセス機能に集中してコンパクトに実装されている。プログラムメモリ、RAMが小さなマイクロコントローラでも実装できるところが魅力である。

もともとはFAT16をサポートしていたが、今回、FAT12,FAT32,exFATアクセス機能を追加した。それに伴いコードサイズ、使用RAMサイズが増加している。

exFAT機能はオプションで切り離し出来るようにして、FAT12,16,32だけなら、プログラムサイズ数kB、使用RAMサイズに抑えたバージョンを使えるように向上させる気持ちがある。

FATファイル機能を使わずにSDcard上に直接フロッピーディスクイメージを置いて使うこともできる。Pico版では、Pico基板上のQSPIフラッシュメモリの末尾256256バイトにイメージを置いて使うこともできるようにしてある(sdcard_picoflash.c)

## eeprom_XXX.c: EEPROMアクセス

autobootのON/OFFや、FATファイル名をEEPROMに保持しておき、次回の起動ではそれを参照することが出来る。

AVR版ではCPU内蔵EEPROMを用いる。Pico版ではQSPI flash最後の1セクタ(4096バイト)の先頭部分10数バイトを使用している。

## led_XXX.c: LEDアクセス

ディスクアクセス時にLEDが点灯(点滅)するようにできる。AVR版ではPC7ピンにLEDを繋いで使うコードになっている。Pico版ではPico基板上のLEDを点灯させる。

AVR版ではタイマー割り込みを使って点滅させている。Pico版ではタイマー割り込みを使わず、Sdcardアクセスの開始と終了で点灯・消灯させている。

## io_XXX.c: 周辺I/O(GPIO)アクセス

AVR版ではIOEXTを接続してパラレルIOを使えるようにしている、らしい。私は使っていないのでノータッチである。

Pico版では空いているPin 8本をGPIOとして使えるようにしてもよいかも(まだできていないし、やらないかもしれない)。



