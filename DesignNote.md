# CP/Mega88設計ノート

この文書は、`@tendai22plus`が行った変更についてのメモだが、
当初の`@toyoshim`さんの設計の背景を想像しつつ、それとの対比で説明したい。

# CP/Mega88とは何か？

* CP/Mを実行する環境である。
* 実8080/Z80 CPUを使わずに、ソフトエミュレートする。
* ソフトエミュレート、RAM、周辺機能(シリアル、フロッピーディスク)
  エミュレートのためのCPUがある。
* CPU内蔵のRAMでは足りない場合、SRAM/DRAMを外付けし、
そこの領域をZ80/8080のメインメモリとする。
* フロッピーディスクの代わりにSDcardを使用する。
* RAM64k環境を提供する。

それぞれに説明を加える。

## CP/M

CP/Mはインテル8080, ザイログZ80 CPU上で動作する、プログラム実行環境・
開発環境である。当時はDOS(Disk Operating System)と呼んでいた。
シリアルコンソールとフロッピードライブを搭載するマイクロコンピュータ上で
動作させることを想定している。

80年代にマイコンを触っていた人たちは、CP/M上で生活していた人もおり、
懐かしくも触ってみたくなる環境といえる。少なくとも私はそう感じている。

## ソフトエミュレート

8080/Z80 CPUのソフトエミューレート機能は容易に手に入る。それを組み込んで
CP/M実行環境を作りたいというのは、昔CP/Mを触っていた人にとっては
魅力的だと思う。

今ならWindows/Linux上で、フロッピードライブやシリアルコンソールをエミュレート
して動作させることも容易だが、CP/Mega88では、それをせず、別途
マイクロコントローラを使いWindows/Linuxを使わず実現できることも特徴だろう。
この「Windows/Linux上ではなく、あえてマイクロコントローラ上で動作させる」
もCP/Mega88の特徴だと思う。

## マイクロコントローラ+RAM+SDcard

CP/M環境を実現するための構成要素は、8080/Z80 CPU、RAM、フロッピードライブ、
シリアルインタフェースである。
これをマイクロコントローラ、RAM、SDcardで実現している。
どれも、今入手可能で比較的安価である。

マイクロコントローラ: CP/Mega88ではその名前が表すように ATmega88を使っている。私は Raspberry Pi Picoで実現したが、ATmega328, PIC18F43Q47、ATmega4323、
STM32、でも実現可能だろう。

ATmega88含め、RAM64kバイト内蔵していないマイクロコントローラは多く、
それらの場合は外付けRAMを使う。マイクロコントローラのGPIOの数が少ない場合は、
RAMアクセスのための出力ピン数を確保するために多重化のために外部バッファを搭載することもある。

フロッピーディスクに代わる記憶媒体が必要になる。当時のフロッピー容量は128kB, 
260kB～12Mbyteであった。今ならSDcard/microSDcard1枚で十分その容量は
まかなえる。

## RAM64k環境

8080, Z80のアドレス空間は16bit、64kBだが、RAMデバイスが高価であったため、
65536バイト全てをROM/RAMで埋めることは憧れの世界であった。
CP/Mは全RAM構成で、RAM容量は最小で20kBから動作させられた。
もちろん、その上で動かすプログラムはそれでは使い物にならないものも多く、
RAM 64kB使える環境は絶対欲しいところである。

# 実現形態のバリエーション

## ソフトエミュレーション

RAM/フロッピーディスク/コンソール全てソフトウェアで実現する。
DOS窓やLinuxシェル上で実行することでコンソール環境となり、
フロッピーディスクをファイルとして実現することが多い。

## マイクロコントローラ+RAM+SDcard

オリジナルのCP/Mega88は`ATmega88`を用いて、外付けRAMを使う。
フロッピーディスク代わりにSDcardを使用する。
SDcard中にフロッピーディスクイメージファイルを置き、それを読み書きするのが一般的であるが、
SDcard上にフロッピーディスクイメージを
焼き込んで使う方法もある。

## マイクロコントローラ内蔵のリソースを用いる。

内蔵RAM上に65536バイトの配列が確保できれば、外付けRAMを使う必要はない。
大量のFLASHメモリを搭載するマイクロコントローラであれば、
そこにフロッピーディスクイメージを置くこともできる。
Raspberry Pi Pico上の実装では、基板上のQSPI Flashメモリ(プログラム搭載用、2MB)の一部にフロッピーディスクイメージを置いた。Pico基板単独でCP/Mega88を動作させている。

# ソフト構成

以後は、マイクロコントローラ上で動作させるソフトウェアの構成を見てゆく。
ソースコード名の`XXX`は、特定のマイクロコントローラ`XXX`専用・機種依存の
コードを含む。

* platform_XXX.c: プラットフォーム、
* monitor.c: モニター
* CPUエミュレーション
* con_XXX.c: シリアルアクセス
* sram_XXX.c: RAMアクセス
* sdcard_XXX.c: sdcardアクセス
* fat.c: FATファイルアクセス
* eeprom_XXX.c: EEPROMアクセス
* led_XXX.c: LEDアクセス
* io_XXX.c: 周辺I/O(GPIO)アクセス

## プラットフォーム(プログラム起動)

platform_XXX.c: `main`関数はここに置く。
main関数は`monitor`関数を呼び出すだけである。

プラットフォーム固有の初期化が必要であれば、`monitor`関数を呼び出す前にやっておくべきだろう。ARM系のCPUだと、クロック設定、メモリ構成の設定を行う必要があるが、`pico-sdk`の初期化がよくできている(`main`関数前に済ませてくれている)ので、ここで特に何もしていない。

マイクロコントローラリセット関数もここで定義している。Pico版では、watchdog timerのハードウェアリセット機能を用いている。pico-sdkのhardware/resetは、
マイクロコントローラのペリフェラルを個別にリセットする機能であり、これを呼び出してもCPU自体はリセットしない。

## モニタ

コマンドラインインタフェース上でコマンドと引数を打ち込み実行させる。
```
(モニターコマンドリスト)
```
メモリダンプ、sdcardセクター読み書きができる。

私の実装では、フラッシュメモリダンプ、XMODEM経由でフロッピーディスクイメージの書き込みと読み出しを追加した。

`m(mount)`コマンドでフロッピーディスクイメージを指定し、
`b(boot)`コマンドでCP/Mシステムをブートし、以後、CP/Mコマンドを使用できる。

CP/M環境で`bye`コマンドを実行するとCP/Mを抜け出しモニターに戻る。

## CPUエミュレーション

8080は2種(cpu_8080.c, i8080.S)、Z80は1種類の実装を含む。コンパイルオプションで選択できる。エミュレーションの質についてはよくわかっていない。CP/Mを動かせる程度には十分ということだろう。

## con_XXX.c: シリアルアクセス

UARTの読み書き、Linux(con_posix.c)では、標準入出力のR/Wである。
1バイト読み込み(timeout指定可能)、1バイト書き込み、受信可能かどうかの3関数を提供する。

## sram_XXX.c: RAMアクセス

1バイト読み書き関数を提供する。

外部RAMの場合はGPIOを叩いてアドレス出力、OE, WEピンのON/OFF、データバスのRead/Writeを行う。内部RAMの場合は、バイト配列 `sram[65536]`を定義しそれへのRead/Writeを提供する。AVR版は前者、PICO版は後者である。

## sdcard_XXX.c: sdcardアクセス

SDcardをSPIモードでアクセスし、カード内の任意のセクタを読み書きする機能を提供する。読み書きするセクタはRAM上のバイト配列(512バイト)上に置かれ、そこへのアクセス関数が提供される。

SPIアクセスは、ハードウェア(マイクロコントローラのSPIコントローラを使用する)とソフトエミュレーション(CS,SCLK,MOSI,MISOをGPIOを使いOn/OffしてSDcardのSPIモードを喋る)がある。

AVR版はソフトエミュレーションを行う。他のマイクロコントローラにも参考になるだろう。Pico版ではSPIコントローラspi0をPin1,2,3,4で使っている。

Unix版は、sdcard_posix.cである。POSIXファイルI/O(fopen,fclose,fread,fwrite,fseek)を用いて、フロッピーディスクイメージを扱う。

## fat.c: FATファイルアクセス

sdcard_XXX.cが提供するセクタRead/Write機能を用いて、SDcard中のFATファイル1本を512バイト単位で読み書きする。

ファイル1本のみ、そのファイルに既にあるセクタのみへのアクセス機能に集中してコンパクトに実装されている。FATファイル生成、書き込み(追加書き込み)の機能を持たない。CP/Mフロッピーディスクのイメージファイルへのセクタリード/ライトだけが出来ればよいという割り切りが心地よい。プログラムメモリ、RAMが小さなマイクロコントローラでも実装できるところが魅力である。

もともとはFAT16をサポートしていたが、今回、FAT12,FAT32,exFATアクセス機能を追加した。それに伴いコードサイズ、使用RAMサイズが増加している。

exFAT機能はオプションで切り離し出来るようにして、FAT12,16,32だけなら、プログラムサイズ数kB、使用RAMサイズに抑えたバージョンを使えるように向上させる気持ちがある。

FATファイル機能を使わずにSDcard上に直接フロッピーディスクイメージを置いて使うこともできる。Pico版では、Pico基板上のQSPIフラッシュメモリの末尾256256バイトにイメージを置いて使うこともできるようにしてある(sdcard_picoflash.c)

## eeprom_XXX.c: EEPROMアクセス

autobootのON/OFFや、FATファイル名をEEPROMに保持しておき、次回の起動ではそれを参照することが出来る。

AVR版ではCPU内蔵EEPROMを用いる。Pico版ではQSPI flash最後の1セクタ(4096バイト)の先頭部分10数バイトを使用している。

## led_XXX.c: LEDアクセス

ディスクアクセス時にLEDが点灯(点滅)するようにできる。AVR版ではPC7ピンにLEDを繋いで使うコードになっている。
Pico版ではPico基板上のLEDを点灯させる。

AVR版ではタイマー割り込みを使って点滅させている。Pico版ではタイマー割り込みを使わず、Sdcardアクセスの開始と終了で点灯・消灯させている。

## io_XXX.c: 周辺I/O(GPIO)アクセス

AVR版ではIOEXTを接続してパラレルIOを使えるようにしている、らしい。私は使っていないのでノータッチである。

Pico版では空いているPin 8本をGPIOとして使えるようにしてもよいかも(まだできていないし、やらないかもしれない)。

# Pico版実装メモ

Pico依存のソースコードはすべて `xxxxx_pico.[ch]` の形式の名前を付けてある。以後、機種依存ソースコード順で Pico版開発のメモを記録する。

## cmakeを使用する

Pico版では、ビルドに `cmake`を使用する。

`CP/Mega88`本来は `Makefile`が用意されており、`make`コマンド一発でターゲットバイナリ(HEXファイル)がビルドされるようになっており、それに合わせたほうがよいのだが、Picoが規定する開発環境では`cmake`を使うことが前提なので、素直に`cmake`を使う方法を採用した。

`make`コマンドによるビルドを実現するには、Makefileを整える必要がある。makeでビルドできるようにMakefileを書く方法が分からないので、結局 cmakeを使ってMakefileを作るしかない。Windows版含めて Pico 開発環境整備の手順書には cmakeインストールまで書かれており、それに従えば環境整備もできるだろう。

## 構成オプション

### 1. SDCardを使うか、内蔵QSPIフラッシュメモリを使うか

+ `-DUSE_FLASH`を指定すると内蔵QSPIフラッシュメモリを使う。
* `-DUSE_SDCARD`を指定するとSDCardを指定する。
* 両方指定した場合、ビルドが通らないはず。

> TODO: -DUSE_SDCARD定義作成と動作確認

### 2. USBシリアルを使うか、ハードウェアシリアルを使うか

* `CMakeLists.txt`を書き換えて切り替える(`pico-sdk`の作法に従えばよい)
* ハードウェアシリアルを使う場合、使用するシリアルデバイス(`uart0`, `uart1`)、GPIOピン番号を変更できる。

### 3. FATイメージファイルを使うか、SDcard全体を使うか(SDCardを使う場合)

* `-DUSE_FAT`を指定するとFATイメージファイルを使う(デフォルト)
* `-DUSE_RAW_SDCARD`を指定するとSDcard全体を使用する。

## ソースコード別実装メモ

### 1. シリアル通信(com_pico.c)

`pico-sdk`では、標準入出力関数(`<stdio.h>`)の先に UARTと USBシリアル(CDCクラス)と両方をサポートしている。Pico版では両方をサポートしている。

具体的には `CMakeFile.txt`で、`pico-sdk`の作法に従い切り替えるだけでよい。以下の3か所。


```
# use UART
pico_enable_stdio_uart(cpmega88 0)
# use USB
pico_enable_stdio_usb(cpmega88 1)
```

上記はUSB CDCを用いる場合である。UARTを使う場合、0, 1を逆に指定して、`com_pico.c`の先頭部分のマクロ
`UART_ID`を `uart0`または`uart1`の形で指定する。

下記が現在のマクロ定義で、`-DUSE_UART`なしで動くようにしてあるはず。コード中にこのマクロが残っているが、消しても動作することを動作確認する必要がある。


```
#if defined(LIB_PICO_STDIO_UART)
//
// USE_UART macros
//
#define UART_ID uart_default
#define BAUD_RATE 115200
// We are using pins 0 and 1, but see the GPIO function select table in the
// datasheet for information on which other pins can be used.
#define UART_TX_PIN 16
#define UART_RX_PIN 17
#endif // defined(LIB_PICO_STDIO_UART)
```

> TODO: USE_UARTマクロ部分を削除し、切り替えビルドを確認する。

## 2. EEPROM

* 内蔵QSPIフラッシュメモリの最後のセクタ(4kB)を使用している。
* マクロ定義はない。`eeprom_pico.c`をビルド対象に加えるだけで本機能が含まれる。

> TODO: ビルド対象に加えるだけでよいかどうか確認

* アクセスは`pico-sdk`の`hardware_flash`のAPIを用いている。
* デバイス自体はQSPIシリアルフラッシュで、eraseはsector(4kB)単位、write(programという)はpage(256byte)単位である。  
  (搭載デバイスにより決まる、この手のデバイスでは、erase 4kB, program 256byteであるように感じている)
* 読み出しは、通常のメモリリードでよい、ポインタ参照、memcpy関数も当然使える。
* 書き込みは erase 4kB単位、program 256バイト単位で行う。書き込みの際には read-modify-write(program)処理が必要になる。

## 3. XMODEMファイルアップロード、ダウンロード

* `-DUSE_FLASH`指定した場合、ファイルアップロード、ダウンロードが使えるようになる。
* 実際には、`-DUSE_FLASH`定義があると、`config.h`内で `-DUSE_XMODEM`が定義される。  
  ビルドターゲットに`xmodem.c`, `crc16.c`に自動追加されないので、これは手で追加する。

## SRAM(8080/Z80が使用するメモリ)

* 内蔵RAMに65536バイトの配列を用意して使っている。
* マクロ定義はない。`sram_pico.c`をターゲットに追加するだけでよい。

## LED

* Pico基板搭載のLEDを使う。
* マクロ定義はない。`led_pico.c`をターゲットに追加するだけでよい。

## machine.c

* `machine.c`は、機種依存部分を含む。もともとはエミュレーション対象のマシンの挙動も定義している。
* `boot`関数のなかで、BDOS/BIOSもRAM上にコピーしている。本来はIPL(フロッピーイメージの先頭128バイト)だけをRAMの0番地からコピーして、CPU自身が(H/W依存の)セクタリードルーチンを呼び出してRAM上に展開すべき(と私は考えている)だが、そうなっていない。
* `prompt`関数: モニタ機能を提供している。2文字コマンドと引数を受けて、関数を呼び出す。引数解析もシンプルに作られている。
* `disk_read`関数、FAT経由のアクセスか、生SDCardのアクセスかを切り替える読み出し関数。書き込みは、読み出しして得たバッファ上のデータを同じセクタに書き込むだけなので、通常の`sdcard_store`関数を呼び出せばよく、わざわざ関数を作る必要がない。
* `mount`関数: FATディスクイメージを`マウント`し、CP/Mフロッピーとして使える準備を行う関数で、`m`コマンドで呼び出される。引数でファイル名(大文字8.3形式)を指定する。`exFAT`形式の場合は、8.3形式でなく、小文字名も含めて、Windows中で見たままのファイル名を指定する(1バイトASCII文字のみ、上限30バイト制限はある)。
* `machine_boot`関数: デバイスの初期化から始まり、`prompt`関数の呼び出しまでCP/Mega88のメイン処理を行う。main関数から直接呼び出される関数。
* `in`, `out`関数: エミュレーション側のIOデバイスの動作を提供する。エミュレーション対象のZ80/8080マシンの周辺回路の機能を提供している。

## I/Oポートの機能

|番号|IN/OUT|機能説明|
|--|--|--|
|0 |IN |シリアル入力。入力文字の値を返す。受信文字がない場合は0xFFを返す|
|1 |OUT|シリアル出力、エスケープシーケンス変換機能あり|
|1 |IN |シリアル入力、文字が入力されるまで待つ|
|10|OUT|ドライブ番号指定|
|10|IN |ドライブ番号を返す|
|11|OUT|トラック番号指定|
|11|IN |トラック番号を返す|
|12|OUT|セクタ番号指定|
|12|IN |セクタ番号を返す|
|13|OUT|0:ディスクリード<br>1: ディスクライト|
|14|IN |ディスクエラー番号を返す|
|15|OUT|DMAアドレスLow指定|
|15|IN |DMAアドレスLow返す|
|16|OUT|DMAアドレスHigh指定|
|16|IN |DMAアドレスHigh返す|


> TODO: ディスクエラー番号(sdcard_flashの返し値)をBIOS仕様に適合させる。

## platform_pico.c

* main関数を含む。本プログラムのエントリポイント。`main`関数は`machine_boot`関数を呼び出しているだけ。
* CP/Mega88システムで使用する機能でない、プラットフォームそのものの初期化は`machine_boot`を呼び出す前に`main`関数の中で行うべきだろう。

## Z80/8080エミュレーション

* `i8080.S`、`cpu_8080.c`がエミュレータである。
* `i8080.S`: AVRアセンブリ言語で記述されている。速そう。
* `cpu_8080.c`: C言語版

## FATファイル操作(fat.c)

`sdcard_fetch`, `sdcard_store`関数を用いて、その上にFATファイル操作機能を作っている。

* `fetch_cluster`関数はクラスタ番号とオフセットを引数にとる。クラスタ番号を先頭クラスタとするファイルの、位置`offset`を含むセクタ(512バイト単位)の値をバッファに読み込む。
* クラスタチェーンを手繰る処理、FATを引いて「次のクラスタ番号」を取り出す処理が入っている。「次のクラスタ番号を得る」部分が、FAT12、FAT16、FAT32、exFATで異なる。

## FATファイルシステム実装

提供される機能は以下の通りです。

* 既に存在するファイルのセクタ読み書きが可能です。ファイルの生成、既存ファイルへの追記、ファイルの削除はできません。
* 複数ファイルを同時に処理できません。一度に扱えるファイルは1つだけです。
* FAT12、FAT16、FAT32、exFATをサポートしています。
* FAT12, FAT16, FAT32において、ファイル名として"8.3形式"のみをサポートしています。FAT32のLFN(Long File Name)、コードページ、ASCII文字以外の文字はサポートしていません。それらの文字を含むファイル名は
  * `m`コマンドで指定できません。
  * `ls`コマンドで正しく表示されません(`.`で代替表示されます)
* exFATにおいて、ファイル名としてASCII文字のみをサポートしています。  
 ファイル名の長さは30文字までで、それを超えるファイル名を扱うことはできません。
  * `m`コマンドの引数(先頭30文字のみ照合されます)
  * `ls`コマンドのファイル名出力表示(30文字を超える部分は表示されません)
> TODO: ファイル名の長さ制限、実装確認まだ不十分、ちゃんとやること必要。

以上
