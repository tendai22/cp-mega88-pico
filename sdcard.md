# SDCardアクセスルーチン

うまくいったりいかなかったり。最近入手できるSD/microSDカードがほとんど使えない状態なので、
初期化とfatアクセスできるように仕立てる。

## 2022/1/13 ここまでの状況

### 1. CP/Mega88のsdcardアクセス機能をpico版にも移植したが、使えるカードが限られている。

* 128GBミニSD、256MB SDは初期化できて、CP/M起動まで確認出来ている。

* 128MB～256MBカード(FAT16)しかDOSファイルアクセスできない。
  * 2GB, 8GBカードはだめ。
  * 2GBカードは、FAT32未対応？初期化でカードを認識するが、ルートディレクトリに置かれたファイルを発見できない。
  * というか、ルートディレクトリのFATアクセスしているように見えない。
  * 8GBカードに至っては、CMD8でリザルトコードR1がC1で返してくる。
* FAT12/16/32の区別付けのロジックが変。fd_desc（BPB の240バイト目)を見て判断している。ChaNさん文書[FATファイルシステムの仕組みと操作法](http://elm-chan.org/docs/fat.html)によると、FATタイプの決定は総クラスタ数で決まる、とあるが、現状そうなっていない。

* 最近のカード、調べてみると2～8GBまでは希少品、入手容易なものは16GB以上であることが分かった。
* exFATは、ChaNさん文書[exFATファイルシステムのしくみと操作法](http://elm-chan.org/docs/exfat.html)を見る。

### 2. テスト用に2G～32Gカードを何枚か買った(あきばおー)。

* コンビニ決済を忘れないように。今晩入金しても発送は来週ですね。

### 3. 次の方向性

* 手持ちの2GB マイクロSDでFATスキャン、CP/Mブートさせる、
* 8GBカードを初期化する(Arduino SD/SD2ライブラリを参考に)
* 入手するカードで動作確認する

# 1/16,17 cp-mega88のfatモジュールをFAT32 FAT12対応にする。

## 最近のSDカード/マイクロSDカードの入手性

最近のSDCard事情を調べてみた。今(2022年1月)、手ごろな価格で手に入るのは2GB～32GBまでのようである。

> あきばおーのSDcarad/microSDのページを見ると、
マイクロSD: 最低でも2GB(Teams製、350円), 値ごろ価格(500円以下)で最大なもので32GBまで。
> SDカード: マイクロSDより高く、2GB(Teams製)でも795円、800円近くする。

よって、2GB～32GBの範囲で使えるフォーマットとして、FAT32対応にしておきたい。

> FATタイプがクラスタ数で決まるということは、ボリュームのサイズによって成り得るFATタイプも決まってくるということが分かります。例えば、セクタサイズを512バイト、クラスタサイズの範囲を512～32Kバイトとした場合、

> FATタイプ	ボリュームサイズ  
FAT12	～128Mバイト  
FAT16	2M～2Gバイト  
FAT32	32M～2Tバイト  

exFAT対応ができれば良いが、調べてみたところややこしそうである。現状のcp-mega88のfatシステムは、FAT16のみ対応しているので、コードを改造してFAT32対応する。

## cp-mega88 の SDCardドライバ、fat用コード

cp-mega88はもともとATmega32U2上で動作させており、コード(バイナリ)サイズが小さい。CP/MのフロッピーイメージのRead/Writeだけで良いので、fat機能は、SDCardのFATファイルとして存在するイメージのRead/Writeのみに特化している。

ファイルの生成、削除は不要であり、長いファイル名、日本語ファイル名もスコープ外としており、コードがコンパクトで、そこに魅力を感じる。ただしFAT16のみサポートしているので、FAT32サポートを追加する。

個人的な事情として、10年以上前にSDカード書き込み機能を使った際に、8MB, 16MB, 64MBのSDカードを集めた。これらはFAT12ファイルシステムなので、これらも使えるとなんとなくうれしい。

FAT32, FAT12のサポートは、FAT(File Allocation Table)を引いて、次のクラスタ番号を算出する機能の違いだけであり、注意してコードを書けばそれほど増えることはない。まず、FAT32, FAT12対応を行う。

## FATファイルシステムの概要(クラスタとFATテーブル)

FATファイルシステムでは、ファイル実体への割り当て単位としてクラスタがある。伝統的に、物理デバイスのR/W単位は512バイト(セクタ)であり、その整数倍の連続領域をクラスタ単位で割り当て管理している。

FAT12, 16, 32の番号は、クラスタ番号のビット表現である。それぞれ12bit, 16bit, 32bitである。このサイズの配列をストレージの先頭部分に格納する。このテーブルをFAT(File Allocation Table)と呼ぶ。

FAT16, 32はそれぞれ１エントリ2バイトまたは4バイトであるが、FAT12は１エントリ1.5バイトで、3バイトの真ん中のバイトを上4bit, 下4bitに分けて、それぞれを前後のバイトとくっつけて12ビットの整数値を保持している。

このテーブルを引く処理は、クラスタ番号を入力として、別のクラスタ番号を出力とする表引きである。この関数を使い、あるクラスタの次のクラスタを保持することができることは想像できると思う。FATシステムにおけるファイルは、クラスタの連鎖である。ディレクトリエントリは8.3形式のファイル名と同時に、そのファイルの先頭クラスタ番号を保持している。ファイルをシーケンシャルリードする場合は、先頭クラスタから順にFATを引いて次のクラスタ番号を取り出すことで行う。

cp-mega88では、fetch_cluster関数で、先頭クラスタとファイル内オフセットを与えると、そのオフセット部分を含むセクターをセクタバッファに読み出す。セクタバッファ内からデータをpeekすることでファイルデータを参照する。pokeした後で、セクタバッファを同じセクタに書き出すことで、ファイル内容を更新できる。

セクタRead/Write(セクタバッファに対する)はsdcard_xxx.cでサポートされており(sdcard_fetch, sdcard_store)、fatアクセス用のコードは、先頭クラスタ番号とファイル内オフセットからセクタを読み込む機能(fetch_cluster)のみである。

改造の対象はfetch_clusterのみでよい。

## FATアクセス機能の要件のまとめ

* コードサイズ的にATmega32u2で動作すること。コード10kB程度、RAMは1～2kB程度。
* CP/Mディスクイメージへのアクセスに限定する。
  * ファイル生成、伸長、削除は不要で、
  * すでに存在するファイル内部の読み出し、書き換えのみとする。
  * ルートディレクトリ内のファイルのみアクセス対象とする。
* FATA16, FAT32をサポートする。可能ならFAT12も。
* sdcardアクセスSPIモードで行う。
* SPIアクセスは、CPU内蔵のSPIペリフェラルに加え、GPIOアクセス版も要する。

QSPIフラッシュをサポートするためには、最小でも4kBバッファ1本を保持できねばならない。PicoはQSPIフラッシュを搭載しているが、外付けでSPI経由でアクセスする基板もたくさんある。RAM容量の少ないCPUの場合、QSPIフラッシュは使えないがSDカードは使えるものも出てくる。

## SDcardの規格

SDアソシエーションの記述によると、[SDCardの容量範囲](https://www.sdcard.org/ja/developers-2/sd-standard-overview/capacity-sd-sdhc-sdxc-sduc/)は、4つあり、それぞれ、SD/SDHC/SDXC/SDUCのロゴで区別できる。

FAT16, FAT32でカバーできるロゴ(容量範囲)は、SDロゴ、SDHCロゴまでとなる。SDHCロゴは上限32GBなので、現在入手できるSDcardをカバーするのに十分である。上記の要件は妥当である。

## FAT仕様書を見る

FAT管理、FATファイルのデータ読み書きを以後説明するに際して、正しい術語を使いたい。正しさの一つの根拠は、標準規格に基づくというものがある。ということで、FAT file systemの仕様書を探してみた。

### ISO/IEC 9293:1994: Volume and file structure of disk cartridge for information interchange

* 国際規格になっている。JIS化もされている。(JIS X0605:1997)
* ISOはスイスからCHF158(スイスフラン。日本円で19,806円(2022年1月))で、JISは3300円。
* JISはWebでテキストだけ読める(https://kikakurui.com/x0/X0605-1997-01.html)

### ECMA-107

全文ダウンロードして入手可能

### Microsoftの仕様書

* Microsoft Extensible Firmware Initiative FAT32 File System Specification
* Version 1.03, December 6, 2000

おそらく[Elm-chanさんの解説](http://elm-chan.org/docs/fat.html)の元ネタと推察できる。Elm-chanさんのサイトを参照。

## FATファイルシステム概要

* セクタ: 物理メディアのアクセス単位、SDcardの場合は512バイトを使用する
* クラスタ: ファイル実体の割り当て単位、番号で指定する。FAT12, 16, 32はクラスタ番号のビット幅を示す。  
  クラスタ番号2番からFF6/FFF6/FFFFFFF6までのクラスタが連続して並んでいる。
* ファイル実体: クラスタの連鎖として表現される。ディレクトリエントリがあり、そこに8.3形式のファイル名と、先頭クラスタの番号だけがある。「次のクラスア番号」を示す表があり、それをFAT(File Access Table)と呼ぶ。
* ファイルアクセス: ファイル先頭のクラスタ番号とファイル内オフセットを指定して、そのオフセットを含むセクタを呼び出すことができる(sdcard_cluster)。
  * ファイル内オフセットから何番目のクラスタを取り出せばよいかは分かる。
  * その回数だけ、先頭のクラスタ番号からFATを引き、得られたクラスタ番号でFATを引く。
  * 目当てのセクターを含むクラスタ番号が得られれば、クラスタ内オフセットから目当てのセクタ番号を算出し、
    そのセクタを読み出す。
  * データを書き込むときは、書き込み領域のセクタを順次呼び出しバッファ上で上書きしたのちに該セクタを書き込む。

## FATファイルシステムの割り当て

* 連続したセクタ上に、ファイルアクセスに必要な情報がある。
  * BPB
  * FAT
  * デイレクとリエントリ
  * ファイル実体(クラスタ)
* それぞれが連続したセクタ領域を占めており、先頭セクタ番号とセクタ換算の長さが分かればこれら情報にアクセスできる。
* ファイルサーチ、ファイル実体アクセスに必要な情報は、ファイルシステム先頭のセクタ(BPB)から得られる。
  * クラスタの大きさ(セクタ数で何セクタか)
  * FAT領域の先頭セクタ番号と長さ、
  * ディレクトリエントリの先頭セクタ番号と長さ、
  * ファイル実体のクラスタの先頭セクタ番号と、長さ(セクタ単位での長さ)


### SDカードにおけるFATファイルシステム

* SDカード初期化のやり方により、先頭セクタの意味が異なる。
  * 先頭がMBR(Master Boot Record): SD Assosiationが提供するフォーマッタで初期化すると、この形式となる。昔のハードディスクと同じ形式で、詳細は省略するが、FATファイルシステムは第1エントリを参照することで得られる。我々は先頭セクタ番号が得られれば十分である。  
  ※) 長さは後述するFATファイルシステムの先頭セクタ内の情報から得られるので。

  * セクタゼロがBPBから始まる: 大昔のフロッピーディスクの形式がこれ。
* 先頭がMBRかBPBかは先頭セクタの中を見ればわかる。

## ファイルを探す: ディレクトリエントリのサーチ

各ファイル1つにつきディレクトリエントリに1つが存在する。ディレクトリエントリは32バイトの大きさで、8.3形式のファイル名と先頭クラスタの番号を持つ。

他に更新時間、生成時間などもあるが、今回の応用では時間情報を使わないので無視する。書き込み時に更新時間の記録も行わない。

ルートディレクトリに存在するファイルのみを扱うので、ルートディレクトリの
ディレクトリエントリ領域に<<<書きかけ>>>

## exFATサポート

* allocation table: 参照できるようにしたが、結局使っていない。
* fatサーチ: ディレクトリエントリが複数個で1ファイルとなったので、32バイトのエントリ１つだけ取り出す
`do_fat_next`と、本来の１ファイル分ずつ取り出す`fat_next`に分けた。exFAT以外は、`fat_next`はいきなり`do_fat_next`を呼び出す。

## FAT32 デバッグ

* 中身が詰まった8GB FAT32カードにMSBAS1.DSKを書き込んでブートしてもブートできない。
tfコマンドでダンプしても全然中身が違う。
* posでバイト単位のオフセットにするために512倍(<<9)するところで桁あふれを起こしていた。
* sdcard_fetch, sdcard_storeの引数をバイト単位からセクタ単位に変更した。
* 最初はsdcard_fetchを残しておいて、sdcard_fetch_sec, sdcard_store_secを新設して、呼び出し側で書き換えていった。

## FAT12デバッグ

* 今度はFAT12でtfコマンドがおかしい。
* top_of_cluster計算がおかしい。直した。

## FAT12,16,32,exFATでtfが動くようになった。

## save 250 foo.tmpも動く。

FAT32のどれかのカードでI/O ERRORが出る。
ほかのカードでは問題ない。
disk imageが壊れているのかも？

これで1/23(1/24夜中)は終わり。ここでいったんコミット、プッシュする。

